

# DFS 核心
**一条路走到黑，走不通再回头，换条路继续走。**
本质就是：**递归 + 回溯**。

---

# 1. DFS 通用模板思路（背会这个）
```
dfs(当前状态) {
    if (已经到终点/满足条件) {
        记录答案 / 输出
        return
    }

    for (遍历所有可能的下一步) {
        if (下一步合法、没走过) {
            标记走过
            dfs(下一步)
            取消标记（回溯）
        }
    }
}
```

拆成 4 步：
1. **出口**：什么时候停止递归
2. **枚举**：所有能走的方向/选择
3. **判断**：能不能走（不越界、没访问过）
4. **递归 + 回溯**：先走，再撤销

---

# 2. 最常见场景：二维网格 DFS（比如迷宫、岛屿）
给你一个网格，上下左右走，不走回头路。

### 思路
1. 越界直接 return
2. 走过/不能走 return
3. 标记当前为已走
4. 往 **上下左右** 四个方向 DFS
5. 不需要回溯（因为一般只需要遍历，不回头）

### 伪代码
```
dfs(grid, x, y) {
    if (x,y 越界 || 不能走 || 已走过)
        return

    标记已走过

    dfs(x-1, y)  // 上
    dfs(x+1, y)  // 下
    dfs(x, y-1)  // 左
    dfs(x, y+1)  // 右
}
```

---

# 3. 另一个常见场景：排列/组合（需要回溯）
比如：全排列、子集、选数组合。

### 思路
1. 选一个数
2. 递归进去
3. **退掉这个数（回溯）**
4. 继续选下一个

---

# 4. DFS 三大关键点（一定要记住）
1. **递归方向**：下一步能去哪
2. **访问标记**：别重复走
3. **递归出口**：防止死循环

---

# 5. 最简单对比
- BFS：**一圈一圈扩散**（像水波纹）
- DFS：**一条路走到头**（像走迷宫钻到底）

---
